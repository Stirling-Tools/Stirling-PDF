import org.gradle.api.artifacts.component.ModuleComponentIdentifier
import org.gradle.api.artifacts.result.ResolvedDependencyResult

configurations {
    vendored
}

tasks.register("vendorAllDeps") {
    group = "vendor"
    description = "Vendors ALL resolved external dependencies into ./maven-repo"

    doLast {
        def localMavenRepo = rootProject.ext.localMavenRepo
        if (localMavenRepo.exists()) {
            localMavenRepo.deleteDir()
        }
        localMavenRepo.mkdirs()

        def includeConfigNames = [
                "compileClasspath",
                "runtimeClasspath",
                "annotationProcessor",
                "testCompileClasspath",
                "testRuntimeClasspath"
        ] as Set

        def seenArtifacts = new HashSet<String>()
        def seenPoms = new HashSet<String>()

        allprojects.each { p ->
            p.configurations.findAll { cfg ->
                cfg.canBeResolved && includeConfigNames.contains(cfg.name)
            }.each { cfg ->
                println "Resolving ${p.path}:${cfg.name}"
                def directModuleIds = cfg.incoming.resolutionResult.root.dependencies
                    .findAll { it instanceof ResolvedDependencyResult }
                    .collect { it.selected.id }
                    .findAll { it instanceof ModuleComponentIdentifier }

                directModuleIds.each { moduleId ->
                    // âœ… Skip: keine eigenen Project-Artefakte vendoren
                    if (moduleId.group == p.group?.toString()) {
                        return
                    }

                    def groupPath = moduleId.group.replace('.', '/')
                    def artifactDir = new File(localMavenRepo, "${groupPath}/${moduleId.module}/${moduleId.version}")
                    artifactDir.mkdirs()

                    def dependencyNotation = "${moduleId.group}:${moduleId.module}:${moduleId.version}"
                    def dep = p.dependencies.create(dependencyNotation)
                    def depConf = p.configurations.detachedConfiguration(dep)
                    depConf.setTransitive(false)

                    // 1) Artifacts (nur direkte Module, keine Transitives)
                    depConf.resolvedConfiguration.lenientConfiguration.artifacts.each { art ->
                        def ext = (art.extension ?: "jar")
                        def classifier = art.classifier ? "-${art.classifier}" : ""
                        def artifactKey = "${moduleId.group}:${moduleId.module}:${moduleId.version}:${ext}:${classifier}"

                        if (seenArtifacts.add(artifactKey)) {
                            copy {
                                duplicatesStrategy = DuplicatesStrategy.EXCLUDE
                                from art.file
                                into artifactDir
                                rename { "${moduleId.module}-${moduleId.version}${classifier}.${ext}" }
                            }
                        }
                    }

                    // 2) POM
                    def pomKey = "${moduleId.group}:${moduleId.module}:${moduleId.version}:pom"
                    if (seenPoms.add(pomKey)) {
                        def pomDep = p.dependencies.create("${dependencyNotation}@pom")
                        def pomConf = p.configurations.detachedConfiguration(pomDep)
                        pomConf.setTransitive(false)
                        def pomFile = pomConf.singleFile

                        copy {
                            duplicatesStrategy = DuplicatesStrategy.EXCLUDE
                            from pomFile
                            into artifactDir
                            rename { "${moduleId.module}-${moduleId.version}.pom" }
                        }
                    }
                }
            }
        }

        println "Done. Vendored artifacts: ${seenArtifacts.size()}, poms: ${seenPoms.size()}"
        println "Local repo: ${localMavenRepo}"
    }
}
