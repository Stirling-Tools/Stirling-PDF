<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PipelineProcessor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stirling-PDF</a> &gt; <a href="index.source.html" class="el_package">stirling.software.SPDF.controller.api.pipeline</a> &gt; <span class="el_source">PipelineProcessor.java</span></div><h1>PipelineProcessor.java</h1><pre class="source lang-java linenums">package stirling.software.SPDF.controller.api.pipeline;

import java.io.*;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.ByteArrayResource;
import org.springframework.core.io.Resource;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.multipart.MultipartFile;

import io.github.pixee.security.Filenames;
import io.github.pixee.security.ZipSecurity;

import jakarta.servlet.ServletContext;

import lombok.extern.slf4j.Slf4j;

import stirling.software.SPDF.SPDFApplication;
import stirling.software.SPDF.model.PipelineConfig;
import stirling.software.SPDF.model.PipelineOperation;
import stirling.software.SPDF.model.PipelineResult;
import stirling.software.SPDF.model.Role;

@Service
<span class="nc" id="L41">@Slf4j</span>
public class PipelineProcessor {

    private final ApiDocService apiDocService;

    private final UserServiceInterface userService;

    private final ServletContext servletContext;

    public PipelineProcessor(
            ApiDocService apiDocService,
            @Autowired(required = false) UserServiceInterface userService,
<span class="nc" id="L53">            ServletContext servletContext) {</span>
<span class="nc" id="L54">        this.apiDocService = apiDocService;</span>
<span class="nc" id="L55">        this.userService = userService;</span>
<span class="nc" id="L56">        this.servletContext = servletContext;</span>
<span class="nc" id="L57">    }</span>

    public static String removeTrailingNaming(String filename) {
        // Splitting filename into name and extension
<span class="nc" id="L61">        int dotIndex = filename.lastIndexOf(&quot;.&quot;);</span>
<span class="nc bnc" id="L62" title="All 2 branches missed.">        if (dotIndex == -1) {</span>
            // No extension found
<span class="nc" id="L64">            return filename;</span>
        }
<span class="nc" id="L66">        String name = filename.substring(0, dotIndex);</span>
<span class="nc" id="L67">        String extension = filename.substring(dotIndex);</span>
        // Finding the last underscore
<span class="nc" id="L69">        int underscoreIndex = name.lastIndexOf(&quot;_&quot;);</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">        if (underscoreIndex == -1) {</span>
            // No underscore found
<span class="nc" id="L72">            return filename;</span>
        }
        // Removing the last part and reattaching the extension
<span class="nc" id="L75">        return name.substring(0, underscoreIndex) + extension;</span>
    }

    private String getApiKeyForUser() {
<span class="nc bnc" id="L79" title="All 2 branches missed.">        if (userService == null) return &quot;&quot;;</span>
<span class="nc" id="L80">        return userService.getApiKeyForUser(Role.INTERNAL_API_USER.getRoleId());</span>
    }

    private String getBaseUrl() {
<span class="nc" id="L84">        String contextPath = servletContext.getContextPath();</span>
<span class="nc" id="L85">        String port = SPDFApplication.getStaticPort();</span>
<span class="nc" id="L86">        return &quot;http://localhost:&quot; + port + contextPath + &quot;/&quot;;</span>
    }

    PipelineResult runPipelineAgainstFiles(List&lt;Resource&gt; outputFiles, PipelineConfig config)
            throws Exception {
<span class="nc" id="L91">        PipelineResult result = new PipelineResult();</span>

<span class="nc" id="L93">        ByteArrayOutputStream logStream = new ByteArrayOutputStream();</span>
<span class="nc" id="L94">        PrintStream logPrintStream = new PrintStream(logStream);</span>
<span class="nc" id="L95">        boolean hasErrors = false;</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">        for (PipelineOperation pipelineOperation : config.getOperations()) {</span>
<span class="nc" id="L97">            String operation = pipelineOperation.getOperation();</span>
<span class="nc" id="L98">            boolean isMultiInputOperation = apiDocService.isMultiInput(operation);</span>
<span class="nc" id="L99">            log.info(</span>
                    &quot;Running operation: {} isMultiInputOperation {}&quot;,
                    operation,
<span class="nc" id="L102">                    isMultiInputOperation);</span>
<span class="nc" id="L103">            Map&lt;String, Object&gt; parameters = pipelineOperation.getParameters();</span>
<span class="nc" id="L104">            List&lt;String&gt; inputFileTypes = apiDocService.getExtensionTypes(false, operation);</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">            if (inputFileTypes == null) {</span>
<span class="nc" id="L106">                inputFileTypes = new ArrayList&lt;String&gt;(Arrays.asList(&quot;ALL&quot;));</span>
            }
            // List outputFileTypes = apiDocService.getExtensionTypes(true, operation);
<span class="nc" id="L109">            String url = getBaseUrl() + operation;</span>
<span class="nc" id="L110">            List&lt;Resource&gt; newOutputFiles = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">            if (!isMultiInputOperation) {</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">                for (Resource file : outputFiles) {</span>
<span class="nc" id="L113">                    boolean hasInputFileType = false;</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">                    for (String extension : inputFileTypes) {</span>
<span class="nc bnc" id="L115" title="All 4 branches missed.">                        if (&quot;ALL&quot;.equals(extension) || file.getFilename().endsWith(extension)) {</span>
<span class="nc" id="L116">                            hasInputFileType = true;</span>
<span class="nc" id="L117">                            MultiValueMap&lt;String, Object&gt; body = new LinkedMultiValueMap&lt;&gt;();</span>
<span class="nc" id="L118">                            body.add(&quot;fileInput&quot;, file);</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">                            for (Entry&lt;String, Object&gt; entry : parameters.entrySet()) {</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">                                if (entry.getValue() instanceof List&lt;?&gt; entryList) {</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">                                    for (Object item : entryList) {</span>
<span class="nc" id="L122">                                        body.add(entry.getKey(), item);</span>
<span class="nc" id="L123">                                    }</span>
                                } else {
<span class="nc" id="L125">                                    body.add(entry.getKey(), entry.getValue());</span>
                                }
<span class="nc" id="L127">                            }</span>
<span class="nc" id="L128">                            ResponseEntity&lt;byte[]&gt; response = sendWebRequest(url, body);</span>
                            // If the operation is filter and the response body is null or empty,
                            // skip
                            // this
                            // file
<span class="nc bnc" id="L133" title="All 2 branches missed.">                            if (operation.startsWith(&quot;filter-&quot;)</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">                                    &amp;&amp; (response.getBody() == null</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">                                            || response.getBody().length == 0)) {</span>
<span class="nc" id="L136">                                result.setFiltersApplied(true);</span>
<span class="nc" id="L137">                                log.info(&quot;Skipping file due to filtering {}&quot;, operation);</span>
<span class="nc" id="L138">                                continue;</span>
                            }
<span class="nc bnc" id="L140" title="All 2 branches missed.">                            if (!HttpStatus.OK.equals(response.getStatusCode())) {</span>
<span class="nc" id="L141">                                logPrintStream.println(&quot;Error: &quot; + response.getBody());</span>
<span class="nc" id="L142">                                hasErrors = true;</span>
<span class="nc" id="L143">                                continue;</span>
                            }
<span class="nc" id="L145">                            processOutputFiles(operation, response, newOutputFiles);</span>
                        }
<span class="nc" id="L147">                    }</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">                    if (!hasInputFileType) {</span>
<span class="nc" id="L149">                        logPrintStream.println(</span>
                                &quot;No files with extension &quot;
<span class="nc" id="L151">                                        + String.join(&quot;, &quot;, inputFileTypes)</span>
                                        + &quot; found for operation &quot;
                                        + operation);
<span class="nc" id="L154">                        hasErrors = true;</span>
                    }
<span class="nc" id="L156">                }</span>
            } else {
                // Filter and collect all files that match the inputFileExtension
                List&lt;Resource&gt; matchingFiles;
<span class="nc bnc" id="L160" title="All 2 branches missed.">                if (inputFileTypes.contains(&quot;ALL&quot;)) {</span>
<span class="nc" id="L161">                    matchingFiles = new ArrayList&lt;&gt;(outputFiles);</span>
                } else {
<span class="nc" id="L163">                    final List&lt;String&gt; finalinputFileTypes = inputFileTypes;</span>
<span class="nc" id="L164">                    matchingFiles =</span>
<span class="nc" id="L165">                            outputFiles.stream()</span>
<span class="nc" id="L166">                                    .filter(</span>
                                            file -&gt;
<span class="nc" id="L168">                                                    finalinputFileTypes.stream()</span>
<span class="nc" id="L169">                                                            .anyMatch(file.getFilename()::endsWith))</span>
<span class="nc" id="L170">                                    .toList();</span>
                }
                // Check if there are matching files
<span class="nc bnc" id="L173" title="All 2 branches missed.">                if (!matchingFiles.isEmpty()) {</span>
                    // Create a new MultiValueMap for the request body
<span class="nc" id="L175">                    MultiValueMap&lt;String, Object&gt; body = new LinkedMultiValueMap&lt;&gt;();</span>
                    // Add all matching files to the body
<span class="nc bnc" id="L177" title="All 2 branches missed.">                    for (Resource file : matchingFiles) {</span>
<span class="nc" id="L178">                        body.add(&quot;fileInput&quot;, file);</span>
<span class="nc" id="L179">                    }</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">                    for (Entry&lt;String, Object&gt; entry : parameters.entrySet()) {</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">                        if (entry.getValue() instanceof List&lt;?&gt; entryList) {</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">                            for (Object item : entryList) {</span>
<span class="nc" id="L183">                                body.add(entry.getKey(), item);</span>
<span class="nc" id="L184">                            }</span>
                        } else {
<span class="nc" id="L186">                            body.add(entry.getKey(), entry.getValue());</span>
                        }
<span class="nc" id="L188">                    }</span>
<span class="nc" id="L189">                    ResponseEntity&lt;byte[]&gt; response = sendWebRequest(url, body);</span>
                    // Handle the response
<span class="nc bnc" id="L191" title="All 2 branches missed.">                    if (HttpStatus.OK.equals(response.getStatusCode())) {</span>
<span class="nc" id="L192">                        processOutputFiles(operation, response, newOutputFiles);</span>
                    } else {
                        // Log error if the response status is not OK
<span class="nc" id="L195">                        logPrintStream.println(</span>
<span class="nc" id="L196">                                &quot;Error in multi-input operation: &quot; + response.getBody());</span>
<span class="nc" id="L197">                        hasErrors = true;</span>
                    }
<span class="nc" id="L199">                } else {</span>
<span class="nc" id="L200">                    logPrintStream.println(</span>
                            &quot;No files with extension &quot;
<span class="nc" id="L202">                                    + String.join(&quot;, &quot;, inputFileTypes)</span>
                                    + &quot; found for multi-input operation &quot;
                                    + operation);
<span class="nc" id="L205">                    hasErrors = true;</span>
                }
            }
<span class="nc" id="L208">            logPrintStream.close();</span>
<span class="nc" id="L209">            outputFiles = newOutputFiles;</span>
<span class="nc" id="L210">        }</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">        if (hasErrors) {</span>
<span class="nc" id="L212">            log.error(&quot;Errors occurred during processing. Log: {}&quot;, logStream.toString());</span>
        }
<span class="nc" id="L214">        result.setHasErrors(hasErrors);</span>
<span class="nc" id="L215">        result.setFiltersApplied(hasErrors);</span>
<span class="nc" id="L216">        result.setOutputFiles(outputFiles);</span>
<span class="nc" id="L217">        return result;</span>
    }

    private ResponseEntity&lt;byte[]&gt; sendWebRequest(String url, MultiValueMap&lt;String, Object&gt; body) {
<span class="nc" id="L221">        RestTemplate restTemplate = new RestTemplate();</span>
        // Set up headers, including API key
<span class="nc" id="L223">        HttpHeaders headers = new HttpHeaders();</span>
<span class="nc" id="L224">        String apiKey = getApiKeyForUser();</span>
<span class="nc" id="L225">        headers.add(&quot;X-API-KEY&quot;, apiKey);</span>
<span class="nc" id="L226">        headers.setContentType(MediaType.MULTIPART_FORM_DATA);</span>
        // Create HttpEntity with the body and headers
<span class="nc" id="L228">        HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; entity = new HttpEntity&lt;&gt;(body, headers);</span>
        // Make the request to the REST endpoint
<span class="nc" id="L230">        return restTemplate.exchange(url, HttpMethod.POST, entity, byte[].class);</span>
    }

    private List&lt;Resource&gt; processOutputFiles(
            String operation, ResponseEntity&lt;byte[]&gt; response, List&lt;Resource&gt; newOutputFiles)
            throws IOException {
        // Define filename
        String newFilename;
<span class="nc bnc" id="L238" title="All 2 branches missed.">        if (operation.contains(&quot;auto-rename&quot;)) {</span>
            // If the operation is &quot;auto-rename&quot;, generate a new filename.
            // This is a simple example of generating a filename using current timestamp.
            // Modify as per your needs.
<span class="nc" id="L242">            newFilename = extractFilename(response);</span>
        } else {
            // Otherwise, keep the original filename.
<span class="nc" id="L245">            newFilename = removeTrailingNaming(extractFilename(response));</span>
        }
        // Check if the response body is a zip file
<span class="nc bnc" id="L248" title="All 2 branches missed.">        if (isZip(response.getBody())) {</span>
            // Unzip the file and add all the files to the new output files
<span class="nc" id="L250">            newOutputFiles.addAll(unzip(response.getBody()));</span>
        } else {
<span class="nc" id="L252">            Resource outputResource =</span>
<span class="nc" id="L253">                    new ByteArrayResource(response.getBody()) {</span>

                        @Override
                        public String getFilename() {
<span class="nc" id="L257">                            return newFilename;</span>
                        }
                    };
<span class="nc" id="L260">            newOutputFiles.add(outputResource);</span>
        }
<span class="nc" id="L262">        return newOutputFiles;</span>
    }

    public String extractFilename(ResponseEntity&lt;byte[]&gt; response) {
        // Default filename if not found
<span class="nc" id="L267">        String filename = &quot;default-filename.ext&quot;;</span>
<span class="nc" id="L268">        HttpHeaders headers = response.getHeaders();</span>
<span class="nc" id="L269">        String contentDisposition = headers.getFirst(HttpHeaders.CONTENT_DISPOSITION);</span>
<span class="nc bnc" id="L270" title="All 4 branches missed.">        if (contentDisposition != null &amp;&amp; !contentDisposition.isEmpty()) {</span>
<span class="nc" id="L271">            String[] parts = contentDisposition.split(&quot;;&quot;);</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">            for (String part : parts) {</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">                if (part.trim().startsWith(&quot;filename&quot;)) {</span>
                    // Extracts filename and removes quotes if present
<span class="nc" id="L275">                    filename = part.split(&quot;=&quot;)[1].trim().replace(&quot;\&quot;&quot;, &quot;&quot;);</span>
<span class="nc" id="L276">                    filename = URLDecoder.decode(filename, StandardCharsets.UTF_8);</span>
<span class="nc" id="L277">                    break;</span>
                }
            }
        }
<span class="nc" id="L281">        return filename;</span>
    }

    List&lt;Resource&gt; generateInputFiles(File[] files) throws Exception {
<span class="nc bnc" id="L285" title="All 4 branches missed.">        if (files == null || files.length == 0) {</span>
<span class="nc" id="L286">            log.info(&quot;No files&quot;);</span>
<span class="nc" id="L287">            return null;</span>
        }
<span class="nc" id="L289">        List&lt;Resource&gt; outputFiles = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">        for (File file : files) {</span>
<span class="nc" id="L291">            Path path = Paths.get(file.getAbsolutePath());</span>
            // debug statement
<span class="nc" id="L293">            log.info(&quot;Reading file: &quot; + path);</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">            if (Files.exists(path)) {</span>
<span class="nc" id="L295">                Resource fileResource =</span>
<span class="nc" id="L296">                        new ByteArrayResource(Files.readAllBytes(path)) {</span>

                            @Override
                            public String getFilename() {
<span class="nc" id="L300">                                return file.getName();</span>
                            }
                        };
<span class="nc" id="L303">                outputFiles.add(fileResource);</span>
<span class="nc" id="L304">            } else {</span>
<span class="nc" id="L305">                log.info(&quot;File not found: &quot; + path);</span>
            }
        }
<span class="nc" id="L308">        log.info(&quot;Files successfully loaded. Starting processing...&quot;);</span>
<span class="nc" id="L309">        return outputFiles;</span>
    }

    List&lt;Resource&gt; generateInputFiles(MultipartFile[] files) throws Exception {
<span class="nc bnc" id="L313" title="All 4 branches missed.">        if (files == null || files.length == 0) {</span>
<span class="nc" id="L314">            log.info(&quot;No files&quot;);</span>
<span class="nc" id="L315">            return null;</span>
        }
<span class="nc" id="L317">        List&lt;Resource&gt; outputFiles = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">        for (MultipartFile file : files) {</span>
<span class="nc" id="L319">            Resource fileResource =</span>
<span class="nc" id="L320">                    new ByteArrayResource(file.getBytes()) {</span>

                        @Override
                        public String getFilename() {
<span class="nc" id="L324">                            return Filenames.toSimpleFileName(file.getOriginalFilename());</span>
                        }
                    };
<span class="nc" id="L327">            outputFiles.add(fileResource);</span>
        }
<span class="nc" id="L329">        log.info(&quot;Files successfully loaded. Starting processing...&quot;);</span>
<span class="nc" id="L330">        return outputFiles;</span>
    }

    private boolean isZip(byte[] data) {
<span class="nc bnc" id="L334" title="All 4 branches missed.">        if (data == null || data.length &lt; 4) {</span>
<span class="nc" id="L335">            return false;</span>
        }
        // Check the first four bytes of the data against the standard zip magic number
<span class="nc bnc" id="L338" title="All 8 branches missed.">        return data[0] == 0x50 &amp;&amp; data[1] == 0x4B &amp;&amp; data[2] == 0x03 &amp;&amp; data[3] == 0x04;</span>
    }

    private List&lt;Resource&gt; unzip(byte[] data) throws IOException {
<span class="nc" id="L342">        log.info(&quot;Unzipping data of length: {}&quot;, data.length);</span>
<span class="nc" id="L343">        List&lt;Resource&gt; unzippedFiles = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L344">        try (ByteArrayInputStream bais = new ByteArrayInputStream(data);</span>
<span class="nc" id="L345">                ZipInputStream zis = ZipSecurity.createHardenedInputStream(bais)) {</span>
            ZipEntry entry;
<span class="nc bnc" id="L347" title="All 2 branches missed.">            while ((entry = zis.getNextEntry()) != null) {</span>
<span class="nc" id="L348">                ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L349">                byte[] buffer = new byte[1024];</span>
                int count;
<span class="nc bnc" id="L351" title="All 2 branches missed.">                while ((count = zis.read(buffer)) != -1) {</span>
<span class="nc" id="L352">                    baos.write(buffer, 0, count);</span>
                }
<span class="nc" id="L354">                final String filename = entry.getName();</span>
<span class="nc" id="L355">                Resource fileResource =</span>
<span class="nc" id="L356">                        new ByteArrayResource(baos.toByteArray()) {</span>

                            @Override
                            public String getFilename() {
<span class="nc" id="L360">                                return filename;</span>
                            }
                        };
                // If the unzipped file is a zip file, unzip it
<span class="nc bnc" id="L364" title="All 2 branches missed.">                if (isZip(baos.toByteArray())) {</span>
<span class="nc" id="L365">                    log.info(&quot;File {} is a zip file. Unzipping...&quot;, filename);</span>
<span class="nc" id="L366">                    unzippedFiles.addAll(unzip(baos.toByteArray()));</span>
                } else {
<span class="nc" id="L368">                    unzippedFiles.add(fileResource);</span>
                }
<span class="nc" id="L370">            }</span>
        }
<span class="nc" id="L372">        log.info(&quot;Unzipping completed. {} files were unzipped.&quot;, unzippedFiles.size());</span>
<span class="nc" id="L373">        return unzippedFiles;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>