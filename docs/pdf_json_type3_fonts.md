# PDF JSON Type3 Font System

## Overview

The PDF Text editor needs to handle **Type3 fonts** - custom vector fonts embedded in PDFs that don't follow standard font formats. These are common in PDFs generated by Matplotlib, LaTeX, scientific papers, and presentation tools.

When converting a PDF to JSON for editing, Type3 fonts present two challenges:
1. **No Unicode mapping** - Character codes don't map to standard Unicode characters
2. **Custom glyphs** - Each font contains vector drawing instructions unique to that PDF

This document explains how the system handles Type3 fonts during the full PDF → JSON → PDF workflow.

---

## Architecture Flow

### PDF → JSON Conversion Flow

```
┌─────────────┐
│  Input PDF  │
└──────┬──────┘
       │
       ▼
┌─────────────────────────────────┐
│  PDFBox Parsing                 │
│  - Extract text positions       │
│  - Identify fonts               │
└──────┬──────────────────────────┘
       │
       ▼
┌─────────────────────────────────┐
│  Font Detection                 │
│  Is this a Type3 font?          │
└──────┬──────────────────────────┘
       │
       ├─── YES (Type3) ───────────────────────┐
       │                                       │
       ▼                                       ▼
┌──────────────────────────┐    ┌──────────────────────────────┐
│  Type3FontConversion     │    │  Extract Type3 Metadata      │
│  Service                 │    │  - Glyph outlines (paths)    │
│                          │    │  - Character codes           │
│  1. Calculate signature  │    │  - Font matrix               │
│  2. Match against        │    │  - Bounding boxes            │
│     library              │    └──────────────────────────────┘
└──────┬───────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│  Library Match?                      │
└──────┬───────────────────────────────┘
       │
       ├─── FOUND ─────────────────────┐
       │                                │
       │                                ▼
       │                   ┌─────────────────────────────┐
       │                   │  Load Pre-built Font        │
       │                   │  - TTF/OTF from library     │
       │                   │  - Full Unicode mappings    │
       │                   │  - Web + PDF payloads       │
       │                   └──────────┬──────────────────┘
       │                                │
       ├─── NOT FOUND ──────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│  Store Type3 Metadata in JSON        │
│  - type3Glyphs: [{charCode, unicode, │
│    glyphName, outline}]              │
│  - Original char codes preserved     │
│  - Font marked as Type3              │
└──────┬───────────────────────────────┘
       │
       ▼
┌─────────────────────────────────────┐
│  PdfJsonDocument Output             │
│  {                                  │
│    fonts: [{                        │
│      id: "F1",                      │
│      baseName: "ABCD+DejaVuSans",   │
│      subtype: "Type3",              │
│      type3Glyphs: [...],            │
│      conversionCandidates: [{       │
│        strategyId: "type3-library", │
│        status: "SUCCESS",           │
│        pdfProgram: "base64...",     │
│        glyphCoverage: [65,66,67...] │
│      }]                             │
│    }],                              │
│    textElements: [{                 │
│      text: "Hello",                 │
│      fontId: "F1",                  │
│      charCodes: [72,101,108,108,111]│
│    }]                               │
│  }                                  │
└─────────────────────────────────────┘
```

### JSON → PDF Conversion Flow

```
┌─────────────────────────────────────┐
│  Input JSON (edited by user)       │
└──────┬──────────────────────────────┘
       │
       ▼
┌─────────────────────────────────────┐
│  Load Fonts from JSON               │
│  - Check for conversionCandidates   │
│  - Check for type3Glyphs            │
└──────┬──────────────────────────────┘
       │
       ▼
┌─────────────────────────────────────┐
│  Has conversionCandidates?          │
└──────┬──────────────────────────────┘
       │
       ├─── YES (Library Match) ───────┐
       │                                │
       │                                ▼
       │                   ┌─────────────────────────────┐
       │                   │  Load from Candidate        │
       │                   │  1. Decode base64 pdfProgram│
       │                   │  2. Create PDType0Font      │
       │                   │  3. Embed in new PDF        │
       │                   └──────────┬──────────────────┘
       │                                │
       ├─── NO (Use Type3 Metadata) ───┘
       │
       ▼
┌──────────────────────────────────────┐
│  Text Rendering Strategy             │
│  - Normalized Type3 fonts:           │
│    Use original text (font has       │
│    Unicode mappings)                 │
│                                      │
│  - Actual Type3 fonts:               │
│    Use charCodes array               │
│                                      │
│  - Other fonts:                      │
│    Standard encoding                 │
└──────┬───────────────────────────────┘
       │
       ▼
┌─────────────────────────────────────┐
│  Generate PDF Content Streams       │
│  - Set font: /F1 12 Tf              │
│  - Position text: x y Td            │
│  - Show text: (encoded) Tj          │
└──────┬──────────────────────────────┘
       │
       ▼
┌─────────────────────────────────────┐
│  Output PDF                         │
│  - Fonts embedded correctly         │
│  - Text renders with proper glyphs  │
│  - Preserves visual appearance      │
└─────────────────────────────────────┘
```

---

## Key Components

### 1. Type3 Font Signature Matching

**Location:** `Type3FontSignatureCalculator.java`

**Purpose:** Creates a unique fingerprint of a Type3 font based on its glyph shapes.

**How it works:**
```java
// 1. Extract glyph outlines from Type3 font
List<Type3GlyphOutline> glyphs = extractor.extractGlyphs(document, font, fontId, pageNumber);

// 2. Normalize and hash the shapes
String signature = calculator.calculateSignature(glyphs);
// Result: "sha256:2be58b6ef1e29a83b8634d70b9e32c37a15dea2e..."

// 3. Look up in library
Optional<Match> match = library.findBySignature(signature);
```

**Signature includes:**
- Glyph outline paths (curves, lines)
- Glyph bounding boxes
- Advance widths
- Character code mappings

### 2. Type3 Font Library

**Location:** `app/core/src/main/resources/type3/library/`

**Structure:**
```
type3/library/
├── index.json           # Font metadata and signatures
├── catalogue.json       # Quick lookup of common fonts
└── fonts/
    ├── dejavu/
    │   ├── DejaVuSans.ttf
    │   ├── DejaVuSans-Bold.ttf
    │   └── DejaVuSans-Oblique.ttf
    ├── cm/              # Computer Modern (LaTeX)
    │   ├── cmr10.ttf
    │   ├── cmmi10.ttf
    │   └── cmsy10.ttf
    ├── stix/            # Scientific symbols
    │   └── STIXSizeThreeSym-Regular.otf
    └── scp/             # Monospace
        └── SauceCodeProNerdFont-Regular.ttf
```

**index.json format:**
```json
[
  {
    "id": "dejavu-sans-bold",
    "label": "DejaVu Sans Bold",
    "aliases": [
      "DejaVuSans-Bold",
      "EVICAO+DejaVuSans-Bold",
      "dejavusans-bold"
    ],
    "signatures": [
      "sha256:a1b2c3d4...",
      "sha256:e5f6g7h8..."
    ],
    "pdfProgram": {
      "resource": "type3/library/fonts/dejavu/DejaVuSans-Bold.ttf",
      "format": "ttf"
    },
    "glyphCoverage": [32, 33, 65, 66, 67, ...],
    "source": "DejaVu Fonts 2.37"
  }
]
```

### 3. Normalized vs Actual Type3 Fonts

The system handles two types of Type3 fonts differently:

**Normalized Type3 Fonts:**
- Original PDF has Type3 font
- Matched against library
- Replaced with standard TTF/OTF
- Font object is `PDType0Font` (not `PDType3Font`)
- Has proper Unicode mappings

**Actual Type3 Fonts:**
- Original PDF has Type3 font
- No library match found
- Keeps Type3 glyph data in JSON
- Font object is `PDType3Font`
- Uses character codes instead of Unicode

**Rendering logic (PdfJsonConversionService.java:2411-2463):**
```java
boolean isNormalizedType3 = !(run.font() instanceof PDType3Font)
    && runFontModel != null
    && runFontModel.getType3Glyphs() != null
    && !runFontModel.getType3Glyphs().isEmpty();

if (isNormalizedType3) {
    // Font has Unicode mappings, use text directly
    contentStream.showText(run.text());
} else {
    // Use raw byte encoding (for Type3 or other fonts)
    byte[] encoded = encodeTextWithFont(run.font(), fontModel, run.text(), charCodes);
    contentStream.showText(new String(encoded, StandardCharsets.ISO_8859_1));
}
```

### 4. Character Code Preservation

**Why needed:** Type3 fonts often lack ToUnicode mappings. We preserve the original character codes so text can be reconstructed.

**Storage in JSON:**
```json
{
  "text": "Hello",
  "fontId": "F1",
  "charCodes": [72, 101, 108, 108, 111]
}
```

**Extraction (PDF → JSON):**
```java
// TextCollectingStripper.java:4431-4443
if (pdfont instanceof PDType3Font) {
    int[] codes = position.getCharacterCodes();
    if (codes != null && codes.length > 0) {
        element.setCharCodes(Arrays.stream(codes)
            .boxed()
            .collect(Collectors.toList()));
    }
}
```

### 5. Font Embedding Strategies

When converting JSON → PDF, fonts are embedded based on their type:

| Font Type | Strategy | Implementation |
|-----------|----------|----------------|
| **Normalized Type3** | Load TTF/OTF from library, embed as PDType0Font | `conversionCandidates[0].pdfProgram` |
| **Standard fonts** | Use system fonts or embedded fonts from original | PDFBox standard loading |
| **CFF/Type1C fonts** | Wrap as OpenType-CFF for browser compatibility | Optional Python converter |
| **Actual Type3** | Keep original Type3 definition | Preserve from original PDF |

---

## Configuration

**settings.yml:**
```yaml
processing:
  pdf-json:
    fonts:
      type3:
        library:
          enabled: true
          index: classpath:/type3/library/index.json
```

**Environment variables:**
```bash
# Disable Type3 library matching
STIRLING_PDF_JSON_TYPE3_LIBRARY_ENABLED=false

# Use custom library
STIRLING_PDF_JSON_TYPE3_LIBRARY_INDEX=file:/path/to/custom/index.json
```

---

## Debugging

### View Type3 Font Information

**Backend logs** show signature matching:
```
[TYPE3] Strategy type3-library finished with status SUCCESS
  (message: Matched DejaVu Sans Bold via alias:dejavusans-bold)
  for font 1:F2

[TYPE3-RUNTIME] Loading library font F2 WITHOUT subsetting
  (full glyph set) from candidate:type3-library:pdfProgram
```

### Check JSON Output

Look for `type3Glyphs` in font definitions:
```json
{
  "id": "F1",
  "baseName": "BMQQDV+DejaVuSans",
  "subtype": "Type3",
  "type3Glyphs": [
    {
      "charCode": 65,
      "glyphName": "A",
      "unicode": 65,
      "advanceWidth": 684,
      "bbox": [0, 0, 684, 729],
      "outline": "M 72 0 L ..."
    }
  ]
}
```

### Test Signature Calculation

Use the CLI tool to analyze any PDF:
```bash
./gradlew :proprietary:type3SignatureTool \
  --args="--pdf sample.pdf --output analysis.json --pretty"
```

Output shows all Type3 fonts with their signatures and glyph coverage.

---

## Performance Considerations

### Memory Management

- **Type3 glyph data** can be large (detailed vector paths)
- **Font subsetting** not used for library fonts (full glyph set loaded)
- **Caching:** Library fonts are loaded once and cached per conversion

### File Size Impact

- **JSON size:** Type3 glyph data adds ~5-50KB per font
- **PDF size:** Embedding TTF/OTF fonts adds ~50-500KB per font
- **Optimization:** Use library matching to avoid storing raw Type3 data

---

## Limitations

1. **Library coverage:** Only common Type3 fonts are in the library
   - Matplotlib (DejaVu Sans family)
   - LaTeX (Computer Modern)
   - STIX Math symbols

2. **Glyph accuracy:** Signature matching assumes exact glyph shapes
   - Slight variations may not match
   - Subset fonts may have different signatures

3. **Unicode mapping:** Unmatched Type3 fonts lose Unicode text
   - Character codes preserved but not searchable
   - Copy/paste may not work correctly

4. **No runtime synthesis:** Unlike earlier designs, no attempt to convert Type3 to TTF at runtime
   - All conversions must be pre-built in library
   - Unknown Type3 fonts keep their Type3 definition

---

## Related Files

### Backend (Java)
- `PdfJsonConversionService.java` - Main conversion logic
- `Type3FontConversionService.java` - Signature calculation and matching
- `Type3FontLibrary.java` - Library loading and lookup
- `Type3GlyphExtractor.java` - Extract glyph data from Type3 fonts
- `Type3FontSignatureCalculator.java` - Create font fingerprints
- `PdfJsonFontType3Glyph.java` - Model for Type3 glyph data

### Frontend (TypeScript)
- `pdfTextEditorTypes.ts` - Type definitions for JSON structure
- `pdfTextEditorUtils.ts` - Font handling utilities

### Resources
- `type3/library/index.json` - Font library metadata
- `type3/library/fonts/` - Actual font files (TTF/OTF)
- `settings.yml.template` - Configuration options

### Documentation
- `pdf_text_edit_flow.md` - Overall text editing architecture
- `type3_fallback_plan.md` - Original design and planning
