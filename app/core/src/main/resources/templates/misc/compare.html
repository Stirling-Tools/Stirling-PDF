<!DOCTYPE html>
<html th:lang="${#locale.language}" th:dir="#{language.direction}" th:data-language="${#locale.toString()}"
  xmlns:th="https://www.thymeleaf.org">

<head>
  <th:block th:insert="~{fragments/common :: head(title=#{compare.title}, header=#{compare.header})}"></th:block>
  <style>
    .result-column {
      border: 1px solid #ccc;
      padding: 15px;
      margin-bottom: 15px;
      overflow-y: auto;
      height: calc(100vh - 400px);
      white-space: pre-wrap;
    }

    .flex-container {
      display: flex;
      flex-direction: row;
    }

    .color-selector {
      display: flex;
      flex-direction: row;
      align-items: center;
      width: 50%;
      max-height: 100px;
      margin-bottom: 2rem;
    }

    #color-box1,
    #color-box2 {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      border: none;
      background-color: transparent;
    }

    .spacer1 {
      padding-right: calc(var(--bs-gutter-x) * .5);
    }

    .spacer2 {
      padding-left: calc(var(--bs-gutter-x) * .5);
    }
  </style>
</head>

<body>
  <div id="page-container">
    <div id="content-wrap">
      <th:block th:insert="~{fragments/navbar.html :: navbar}"></th:block>
      <br><br>
      <div class="container">
        <div class="row justify-content-center">
          <div class="col-md-9 bg-card">
            <div class="tool-header">
              <span class="material-symbols-rounded tool-header-icon other">compare</span>
              <span class="tool-header-text" th:text="#{compare.header}"></span>
            </div>
            <div
              th:replace="~{fragments/common :: fileSelector(name='fileInput', disableMultipleFiles=true, multipleInputsForSingleRequest=false, accept='application/pdf', remoteCall='false')}">
            </div>
            <div
              th:replace="~{fragments/common :: fileSelector(name='fileInput2', disableMultipleFiles=true, multipleInputsForSingleRequest=false, accept='application/pdf', remoteCall='false')}">
            </div>

            <div class="row">
              <div class="flex-container">
                <div class="color-selector spacer1">
                  <label th:text="#{compare.highlightColor.1}"></label>
                  <label for="color-box1"></label><input type="color" id="color-box1" value="#ff0000">
                </div>
                <div class="color-selector spacer2">
                  <label th:text="#{compare.highlightColor.2}"></label>
                  <label for="color-box2"></label><input type="color" id="color-box2" value="#008000">
                </div>
              </div>
            </div>

            <button class="btn btn-primary" id="compareBtn" onclick="comparePDFs(event)" th:text="#{compare.submit}"></button>

            <div class="row">
              <div class="col-md-6">
                <h3 th:text="#{compare.document.1}"></h3>
                <div id="result1" class="result-column"></div>
              </div>
              <div class="col-md-6">
                <h3 th:text="#{compare.document.2}"></h3>
                <div id="result2" class="result-column"></div>
              </div>
            </div>
            <script type="module" th:src="@{'/pdfjs-legacy/pdf.mjs'}"></script>
            <script th:inline="javascript">
              // get the elements
              var result1 = document.getElementById('result1');
              var result2 = document.getElementById('result2');

              // add event listeners
              result1.addEventListener('scroll', function () {
                result2.scrollTop = result1.scrollTop;
              });

              result2.addEventListener('scroll', function () {
                result1.scrollTop = result2.scrollTop;
              });

              async function comparePDFs(event) {
                const file1 = document.getElementById("fileInput-input").files[0];
                const file2 = document.getElementById("fileInput2-input").files[0];
                var color1 = document.getElementById('color-box1').value;
                var color2 = document.getElementById('color-box2').value;

                const complexMessage = /*[[#{compare.complex.message}]]*/ 'One or both of the provided documents are large files, accuracy of comparison may be reduced';
                const largeFilesMessage = /*[[#{compare.large.file.message}]]*/ 'One or Both of the provided documents are too large to process';
                const noTextMessage = /*[[#{compare.no.text.message}]]*/ 'One or both of the selected PDFs have no text content. Please choose PDFs with text for comparison.';
                const invalidPdfMessage = /*[[#{compare.invalid.pdf.message}]]*/ 'One or both files are not valid PDFs. Please check and re-upload.';
                const submitText = /*[[#{compare.submit}]]*/ 'Compare';

                if (!file1 || !file2) {
                  alert('Please select two PDF files to compare');
                  return;
                }

                // Basic checks
                if (file1.size === 0 || file2.size === 0) {
                  alert('One or both files are empty.');
                  return;
                }
                if (file1.size > 100 * 1024 * 1024 || file2.size > 100 * 1024 * 1024) {
                  alert(largeFilesMessage);
                  return;
                }

                // PDF.js setup (Legacy-safe: Worker disabled)
                const PDFJS_DEFAULT_OPTIONS = {
                  cMapUrl: pdfjsPath + 'cmaps/',
                  cMapPacked: true,
                  standardFontDataUrl: pdfjsPath + 'standard_fonts/',
                  disableWorker: true  // Avoids Legacy CMap errors without changing PDF.js
                };
                pdfjsLib.GlobalWorkerOptions.workerSrc = pdfjsPath + 'pdf.worker.mjs';

                const button = event.target;
                button.disabled = true;
                button.textContent = 'Processing...';

                try {
                  // Load ArrayBuffer
                  const [data1, data2] = await Promise.all([
                    readFileAsArrayBuffer(file1),
                    readFileAsArrayBuffer(file2)
                  ]);

                  // Header validation (prevents InvalidPDFException)
                  await validatePdfHeader(data1, 'File 1');
                  await validatePdfHeader(data2, 'File 2');

                  // Load PDFs
                  const [pdf1, pdf2] = await Promise.all([
                    loadPdfWithErrorHandling({ ...PDFJS_DEFAULT_OPTIONS, data: data1 }, 'File 1'),
                    loadPdfWithErrorHandling({ ...PDFJS_DEFAULT_OPTIONS, data: data2 }, 'File 2')
                  ]);

                  // Extract text
                  result1.innerHTML = 'Extracting text from File 1...';
                  result2.innerHTML = 'Extracting text from File 2...';
                  const [text1, text2] = await Promise.all([
                    extractText(pdf1, 'File 1', result1),
                    extractText(pdf2, 'File 2', result2)
                  ]);

                  if (text1.trim() === "" || text2.trim() === "") {
                    throw new Error(noTextMessage);
                  }

                  // Worker diff
                  await processWithWorker(text1, text2, color1, color2, complexMessage, largeFilesMessage);

                } catch (error) {
                  console.error('Comparison failed:', error);
                  alert(error.message || invalidPdfMessage);
                  result1.innerHTML = '';
                  result2.innerHTML = '';
                } finally {
                  button.disabled = false;
                  button.textContent = submitText;
                }
              }

              // FileReader helper
              function readFileAsArrayBuffer(file) {
                return new Promise((resolve, reject) => {
                  const reader = new FileReader();
                  reader.onload = () => resolve(reader.result);
                  reader.onerror = reject;
                  reader.readAsArrayBuffer(file);
                });
              }

              // Header validation (PDF.js-specific, but client-side)
              async function validatePdfHeader(data, fileName) {
                const header = new Uint8Array(data.slice(0, 8));
                const headerStr = String.fromCharCode(...header);
                console.log(`${fileName} header:`, headerStr);
                if (!headerStr.startsWith('%PDF-')) {
                  throw new Error(`${fileName} is not a valid PDF (header: ${headerStr}).`);
                }
                if (data.byteLength < 100) {
                  throw new Error(`${fileName} is too short.`);
                }
              }

              // PDF loading with catch
              function loadPdfWithErrorHandling(options, fileName) {
                return pdfjsLib.getDocument(options).promise
                  .then(pdf => {
                    console.log(`${fileName} loaded: ${pdf.numPages} pages`);
                    return pdf;
                  })
                  .catch(err => {
                    console.error(`${fileName} load failed:`, err);
                    if (err.name === 'InvalidPDFException') {
                      throw new Error(`${fileName}: Invalid PDF structure. Re-upload.`);
                    }
                    throw err;
                  });
              }

              // Text extraction
              async function extractText(pdf, fileName, statusElement) {
                const pages = [];
                const totalPages = pdf.numPages;
                for (let i = 1; i <= totalPages; i++) {
                  const page = await pdf.getPage(i);
                  const content = await page.getTextContent();
                  const strings = content.items.map(item => item.str).join(' ');
                  pages.push(strings);
                  statusElement.innerHTML = `${fileName}: ${Math.round((i / totalPages) * 100)}%`;
                }
                return pages.join(' ');
              }

              // Worker processing
              async function processWithWorker(text1, text2, color1, color2, complexMessage, largeFilesMessage) {
                return new Promise((resolve, reject) => {
                  const worker = new Worker('./js/compare/pdfWorker.js');
                  const timeout = setTimeout(() => {
                    worker.terminate();
                    reject(new Error('Timeout: Files too complex.'));
                  }, 30000);

                  worker.postMessage({ type: 'SET_COMPLEX_MESSAGE', message: complexMessage });
                  worker.postMessage({ type: 'SET_TOO_LARGE_MESSAGE', message: largeFilesMessage });

                  worker.onerror = (error) => {
                    clearTimeout(timeout);
                    worker.terminate();
                    reject(new Error('Worker error: ' + error.message));
                  };

                  worker.onmessage = (e) => {
                    clearTimeout(timeout);
                    const { status, differences, message } = e.data;
                    if (status === 'error') {
                      worker.terminate();
                      reject(new Error(message));
                      return;
                    }
                    if (status === 'warning') {
                      alert(message);
                    }
                    if (status === 'success' && differences) {
                      displayDifferences(differences, color1, color2);
                      worker.terminate();
                      resolve();
                    }
                  };

                  worker.postMessage({ type: 'COMPARE', text1, text2, color1, color2 });
                });
              }

              // Display differences
              function displayDifferences(differences, color1, color2) {
                const resultDiv1 = document.getElementById("result1");
                const resultDiv2 = document.getElementById("result2");
                resultDiv1.innerHTML = "";
                resultDiv2.innerHTML = "";

                differences.forEach(([color, word]) => {
                  const span1 = document.createElement("span");
                  const span2 = document.createElement("span");

                  if (color === color2) {
                    span1.style.color = "transparent";
                    span1.style.userSelect = "none";
                    span2.style.color = color;
                  } else if (color === color1) {
                    span1.style.color = color;
                    span2.style.color = "transparent";
                    span2.style.userSelect = "none";
                  } else {
                    span1.style.color = color || 'black';
                    span2.style.color = color || 'black';
                  }

                  span1.textContent = word;
                  span2.textContent = word;
                  resultDiv1.appendChild(span1);
                  resultDiv2.appendChild(span2);

                  const spaceOrNewline1 = document.createElement("span");
                  const spaceOrNewline2 = document.createElement("span");
                  if (word.endsWith(".")) {
                    spaceOrNewline1.innerHTML = "<br>";
                    spaceOrNewline2.innerHTML = "<br>";
                  } else {
                    spaceOrNewline1.textContent = " ";
                    spaceOrNewline2.textContent = " ";
                  }
                  resultDiv1.appendChild(spaceOrNewline1);
                  resultDiv2.appendChild(spaceOrNewline2);
                });
              }
            </script>
          </div>
        </div>
      </div>
    </div>
    <th:block th:insert="~{fragments/footer.html :: footer}"></th:block>
  </div>
</body>

</html>