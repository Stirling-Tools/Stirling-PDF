import { useCallback, useEffect, useMemo, useState, useRef } from 'react';
import { useTranslation } from 'react-i18next';
import DescriptionIcon from '@mui/icons-material/DescriptionOutlined';

import { useToolWorkflow } from '../contexts/ToolWorkflowContext';
import { useNavigationActions, useNavigationState } from '../contexts/NavigationContext';
import { BaseToolProps, ToolComponent } from '../types/tool';
import { CONVERSION_ENDPOINTS } from '../constants/convertConstants';
import apiClient from '../services/apiClient';
import { downloadBlob, downloadTextAsFile } from '../utils/downloadUtils';
import { getFilenameFromHeaders } from '../utils/fileResponseUtils';
import {
  PdfJsonDocument,
  TextGroup,
  PdfJsonEditorViewData,
} from './pdfJsonEditorTypes';
import {
  deepCloneDocument,
  getDirtyPages,
  groupDocumentText,
  restoreGlyphElements,
} from './pdfJsonEditorUtils';
import PdfJsonEditorView from '../components/tools/pdfJsonEditor/PdfJsonEditorView';

const VIEW_ID = 'pdfJsonEditorView';
const WORKBENCH_ID = 'custom:pdfJsonEditor' as const;

const sanitizeBaseName = (name?: string | null): string => {
  if (!name || name.trim().length === 0) {
    return 'document';
  }
  return name.replace(/\.[^.]+$/u, '');
};

const PdfJsonEditor = ({ onComplete, onError }: BaseToolProps) => {
  const { t } = useTranslation();
  const {
    registerCustomWorkbenchView,
    unregisterCustomWorkbenchView,
    setCustomWorkbenchViewData,
    clearCustomWorkbenchViewData,
    setLeftPanelView,
  } = useToolWorkflow();
  const { actions: navigationActions } = useNavigationActions();
  const navigationState = useNavigationState();

  const [loadedDocument, setLoadedDocument] = useState<PdfJsonDocument | null>(null);
  const [groupsByPage, setGroupsByPage] = useState<TextGroup[][]>([]);
  const [selectedPage, setSelectedPage] = useState(0);
  const [fileName, setFileName] = useState('');
  const [errorMessage, setErrorMessage] = useState<string | null>(null);
  const [isGeneratingPdf, setIsGeneratingPdf] = useState(false);
  const [isConverting, setIsConverting] = useState(false);

  const dirtyPages = useMemo(() => getDirtyPages(groupsByPage), [groupsByPage]);
  const hasChanges = useMemo(() => dirtyPages.some(Boolean), [dirtyPages]);
  const hasDocument = loadedDocument !== null;
  const viewLabel = useMemo(() => t('pdfJsonEditor.viewLabel', 'PDF Editor'), [t]);

  const resetToDocument = useCallback((document: PdfJsonDocument | null) => {
    if (!document) {
      setGroupsByPage([]);
      setSelectedPage(0);
      return;
    }
    const cloned = deepCloneDocument(document);
    const groups = groupDocumentText(cloned);
    setGroupsByPage(groups);
    setSelectedPage(0);
  }, []);

  const handleLoadFile = useCallback(
    async (file: File | null) => {
      if (!file) {
        return;
      }

      const isPdf = file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf');

      try {
        let parsed: PdfJsonDocument;

        if (isPdf) {
          // Convert PDF to JSON first
          setIsConverting(true);
          setErrorMessage(null);

          const formData = new FormData();
          formData.append('fileInput', file);

          const response = await apiClient.post(CONVERSION_ENDPOINTS['pdf-json'], formData, {
            responseType: 'blob',
          });

          const jsonText = await response.data.text();
          parsed = JSON.parse(jsonText) as PdfJsonDocument;
        } else {
          // Load JSON directly
          const content = await file.text();
          parsed = JSON.parse(content) as PdfJsonDocument;
        }

        setLoadedDocument(parsed);
        resetToDocument(parsed);
        setFileName(file.name);
        setErrorMessage(null);
      } catch (error) {
        console.error('Failed to load file', error);
        setLoadedDocument(null);
        setGroupsByPage([]);

        if (isPdf) {
          setErrorMessage(
            t('pdfJsonEditor.conversionFailed', 'Failed to convert PDF. Please try again.')
          );
        } else {
          setErrorMessage(
            t(
              'pdfJsonEditor.errors.invalidJson',
              'Unable to read the JSON file. Ensure it was generated by the PDF to JSON tool.'
            )
          );
        }
      } finally {
        setIsConverting(false);
      }
    },
    [resetToDocument, t]
  );

  const handleSelectPage = useCallback((pageIndex: number) => {
    setSelectedPage(pageIndex);
  }, []);

  const handleGroupTextChange = useCallback((pageIndex: number, groupId: string, value: string) => {
    setGroupsByPage((previous) =>
      previous.map((groups, idx) =>
        idx !== pageIndex
          ? groups
          : groups.map((group) => (group.id === groupId ? { ...group, text: value } : group))
      )
    );
  }, []);

  const handleResetEdits = useCallback(() => {
    if (!loadedDocument) {
      return;
    }
    resetToDocument(loadedDocument);
    setErrorMessage(null);
  }, [loadedDocument, resetToDocument]);

  const buildPayload = useCallback(() => {
    if (!loadedDocument) {
      return null;
    }

    const updatedDocument = restoreGlyphElements(loadedDocument, groupsByPage);
    const baseName = sanitizeBaseName(fileName || loadedDocument.metadata?.title || undefined);
    return {
      document: updatedDocument,
      filename: `${baseName}.json`,
    };
  }, [fileName, groupsByPage, loadedDocument]);

  const handleDownloadJson = useCallback(() => {
    const payload = buildPayload();
    if (!payload) {
      return;
    }

    const { document, filename } = payload;
    const serialized = JSON.stringify(document, null, 2);
    downloadTextAsFile(serialized, filename, 'application/json');

    if (onComplete) {
      const exportedFile = new File([serialized], filename, { type: 'application/json' });
      onComplete([exportedFile]);
    }
  }, [buildPayload, onComplete]);

  const handleGeneratePdf = useCallback(async () => {
    const payload = buildPayload();
    if (!payload) {
      return;
    }

    const { document, filename } = payload;
    const serialized = JSON.stringify(document, null, 2);
    const jsonFile = new File([serialized], filename, { type: 'application/json' });

    const formData = new FormData();
    formData.append('fileInput', jsonFile);

    try {
      setIsGeneratingPdf(true);
      const response = await apiClient.post(CONVERSION_ENDPOINTS['json-pdf'], formData, {
        responseType: 'blob',
      });

      const contentDisposition = response.headers?.['content-disposition'] ?? '';
      const detectedName = getFilenameFromHeaders(contentDisposition);
      const baseName = sanitizeBaseName(filename).replace(/-edited$/u, '');
      const downloadName = detectedName || `${baseName || 'document'}.pdf`;

      downloadBlob(response.data, downloadName);

      if (onComplete) {
        const pdfFile = new File([response.data], downloadName, { type: 'application/pdf' });
        onComplete([pdfFile]);
      }
      setErrorMessage(null);
    } catch (error: any) {
      console.error('Failed to convert JSON back to PDF', error);
      const message =
        error?.response?.data ||
        error?.message ||
        t('pdfJsonEditor.errors.pdfConversion', 'Unable to convert the edited JSON back into a PDF.');
      const msgString = typeof message === 'string' ? message : String(message);
      setErrorMessage(msgString);
      if (onError) {
        onError(msgString);
      }
    } finally {
      setIsGeneratingPdf(false);
    }
  }, [buildPayload, onComplete, onError, t]);

  const viewData = useMemo<PdfJsonEditorViewData>(() => ({
    document: loadedDocument,
    groupsByPage,
    selectedPage,
    dirtyPages,
    hasDocument,
    fileName,
    errorMessage,
    isGeneratingPdf,
    isConverting,
    hasChanges,
    onLoadJson: handleLoadFile,
    onSelectPage: handleSelectPage,
    onGroupEdit: handleGroupTextChange,
    onReset: handleResetEdits,
    onDownloadJson: handleDownloadJson,
    onGeneratePdf: handleGeneratePdf,
  }), [
    dirtyPages,
    errorMessage,
    fileName,
    groupsByPage,
    handleDownloadJson,
    handleGeneratePdf,
    handleGroupTextChange,
    handleLoadFile,
    handleResetEdits,
    handleSelectPage,
    hasChanges,
    hasDocument,
    isGeneratingPdf,
    isConverting,
    loadedDocument,
    selectedPage,
  ]);

  const latestViewDataRef = useRef<PdfJsonEditorViewData>(viewData);
  latestViewDataRef.current = viewData;

  useEffect(() => {
    registerCustomWorkbenchView({
      id: VIEW_ID,
      workbenchId: WORKBENCH_ID,
      label: viewLabel,
      icon: <DescriptionIcon fontSize="small" />,
      component: PdfJsonEditorView,
    });
    setLeftPanelView('hidden');
    setCustomWorkbenchViewData(VIEW_ID, latestViewDataRef.current);

    return () => {
      clearCustomWorkbenchViewData(VIEW_ID);
      unregisterCustomWorkbenchView(VIEW_ID);
      setLeftPanelView('toolPicker');
    };
  }, [
    clearCustomWorkbenchViewData,
    registerCustomWorkbenchView,
    setCustomWorkbenchViewData,
    setLeftPanelView,
    viewLabel,
    unregisterCustomWorkbenchView,
  ]);

  useEffect(() => {
    if (
      navigationState.selectedTool === 'pdfJsonEditor' &&
      navigationState.workbench !== WORKBENCH_ID
    ) {
      navigationActions.setWorkbench(WORKBENCH_ID);
    }
  }, [navigationActions, navigationState.selectedTool, navigationState.workbench]);

  const lastSentViewDataRef = useRef<PdfJsonEditorViewData | null>(null);

  useEffect(() => {
    if (lastSentViewDataRef.current === viewData) {
      return;
    }
    lastSentViewDataRef.current = viewData;
    setCustomWorkbenchViewData(VIEW_ID, viewData);
  }, [setCustomWorkbenchViewData, viewData]);

  // All editing happens in the custom workbench view.
  return null;
};

(PdfJsonEditor as ToolComponent).tool = () => {
  throw new Error('PDF JSON Editor does not support automation operations.');
};

(PdfJsonEditor as ToolComponent).getDefaultParameters = () => ({
  groups: [],
});

export default PdfJsonEditor as ToolComponent;
